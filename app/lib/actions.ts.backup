'use server';
import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import postgres from 'postgres';
import { auth, signIn } from '@/auth';
import { AuthError } from 'next-auth';
import bcrypt from 'bcrypt';
 
const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' }); 

// Sch√©mas de validation
const UserSchema = z.object({
  name: z.string().min(1, 'Le nom est requis'),
  email: z.string().email('Email invalide'),
  password: z.string().min(6, 'Le mot de passe doit contenir au moins 6 caract√®res'),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Les mots de passe ne correspondent pas",
  path: ["confirmPassword"],
});

const ActivitySchema = z.object({
  id: z.string(),
  userId: z.string(),
  name: z.string().min(1, 'Le nom de l\'activit√© est requis'),
  frequency: z.enum(['daily', 'weekly', 'monthly']),
  createdAt: z.string(),
});

const CreateActivity = ActivitySchema.omit({ id: true, createdAt: true });

// Actions pour les utilisateurs
export async function signup(
  prevState: string | undefined,
  formData: FormData,
) {
  try {
    const rawFormData = {
      name: formData.get('name'),
      email: formData.get('email'),
      password: formData.get('password'),
      confirmPassword: formData.get('confirmPassword'),
    };

    const validatedFields = UserSchema.safeParse(rawFormData);

    if (!validatedFields.success) {
      return validatedFields.error.errors[0]?.message || 'Donn√©es invalides';
    }

    const { name, email, password } = validatedFields.data;

    // V√©rifier si l'utilisateur existe d√©j√†
    const existingUser = await sql`
      SELECT id FROM users WHERE email = ${email}
    `;

    if (existingUser.length > 0) {
      return 'Un utilisateur avec cet email existe d√©j√†';
    }

    // Hasher le mot de passe
    const hashedPassword = await bcrypt.hash(password, 10);

    // Cr√©er l'utilisateur
    await sql`
      INSERT INTO users (name, email, password_hash, created_at, last_login)
      VALUES (${name}, ${email}, ${hashedPassword}, ${new Date().toISOString()}, ${new Date().toISOString()})
    `;

    console.log('‚úÖ Utilisateur cr√©√© avec succ√®s:', email);
    
  } catch (error) {
    console.error('Erreur lors de l\'inscription:', error);
    if ((error as any).code === '23505') { // Duplicate key error
      return 'Un utilisateur avec cet email existe d√©j√†';
    }
    return 'Une erreur est survenue lors de la cr√©ation du compte';
  }
  
  // Rediriger vers la page de connexion avec un message de succ√®s
  redirect('/login?success=inscription');
}

// Actions pour les activit√©s
export async function createActivity(
  prevState: string | undefined,
  formData: FormData,
) {
  try {
    // R√©cup√©rer l'utilisateur connect√© depuis la session
    const session = await auth();
    if (!session?.user?.email) {
      return 'Vous devez √™tre connect√© pour cr√©er une activit√©';
    }

    // R√©cup√©rer l'ID de l'utilisateur
    const userResult = await sql`
      SELECT id FROM users WHERE email = ${session.user.email}
    `;
    
    if (userResult.length === 0) {
      return 'Utilisateur non trouv√©';
    }

    const userId = userResult[0].id;
    const name = formData.get('name') as string;
    const frequency = formData.get('frequency') as string;
    const color = formData.get('color') as string || '#10B981';
    const icon = formData.get('icon') as string || '‚úÖ';
    const startDate = formData.get('startDate') as string || new Date().toISOString().split('T')[0];
    const category = formData.get('category') as string || 'other';

    // Validation
    if (!name || name.trim().length === 0) {
      return 'Le nom de l\'activit√© est requis';
    }

    if (!['daily', 'weekly', 'monthly'].includes(frequency)) {
      return 'Fr√©quence invalide';
    }

    // Cr√©er l'activit√©
    await sql`
      INSERT INTO activities (user_id, name, frequency, color, icon, start_date, category, created_at)
      VALUES (${userId}, ${name}, ${frequency}, ${color}, ${icon}, ${startDate}, ${category}, ${new Date().toISOString()})
    `;

    console.log('‚úÖ Activit√© cr√©√©e avec succ√®s:', name);
    revalidatePath('/dashboard/activities');
    revalidatePath('/dashboard/home');
  } catch (error) {
    console.error('‚ùå Erreur lors de la cr√©ation de l\'activit√©:', error);
    return 'Une erreur est survenue lors de la cr√©ation de l\'activit√©';
  }

  // Rediriger vers la page des activit√©s
  redirect('/dashboard/activities');
}

export async function updateActivity(id: string, formData: FormData) {
  const { userId, name, frequency } = CreateActivity.parse({
    userId: formData.get('userId'),
    name: formData.get('name'),
    frequency: formData.get('frequency'),
  });

  await sql`
    UPDATE activities
    SET name = ${name}, frequency = ${frequency}
    WHERE id = ${id} AND user_id = ${userId}
  `;

  revalidatePath('/dashboard/activities');
  redirect('/dashboard/activities');
}

export async function deleteActivity(id: string, userId: string) {
  // Supprimer les logs associ√©s
  await sql`DELETE FROM activity_logs WHERE activity_id = ${id}`;
  
  // Supprimer l'activit√©
  await sql`DELETE FROM activities WHERE id = ${id} AND user_id = ${userId}`;
  
  revalidatePath('/dashboard/activities');
}

export async function logActivity(activityId: string, isDone: boolean) {
  const today = new Date().toISOString().split('T')[0];
  
  // R√©cup√©rer la session pour obtenir l'utilisateur
  const session = await auth();
  if (!session?.user?.email) {
    throw new Error('Non authentifi√©');
  }

  // R√©cup√©rer l'utilisateur et l'activit√©
  const userResult = await sql`SELECT id FROM users WHERE email = ${session.user.email}`;
  const activityResult = await sql`SELECT category FROM activities WHERE id = ${activityId}`;
  
  if (userResult.length === 0 || activityResult.length === 0) {
    throw new Error('Utilisateur ou activit√© non trouv√©');
  }

  const userId = userResult[0].id;
  const activityCategory = activityResult[0].category;
  
  // V√©rifier si un log existe d√©j√† pour aujourd'hui
  const existingLog = await sql`
    SELECT id FROM activity_logs 
    WHERE activity_id = ${activityId} AND date = ${today}
  `;

  if (existingLog.length > 0) {
    // Mettre √† jour le log existant
    await sql`
      UPDATE activity_logs
      SET is_done = ${isDone}
      WHERE activity_id = ${activityId} AND date = ${today}
    `;
  } else {
    // Cr√©er un nouveau log
    await sql`
      INSERT INTO activity_logs (activity_id, date, is_done)
      VALUES (${activityId}, ${today}, ${isDone})
    `;
  }

  // Mettre √† jour les d√©fis journaliers si l'activit√© est compl√©t√©e
  if (isDone) {
    // S'assurer que les d√©fis journaliers existent pour aujourd'hui
    const dailyChallengeExists = await sql`
      SELECT id FROM daily_challenges
      WHERE user_id = ${userId} AND challenge_date = ${today}
    `;

    if (dailyChallengeExists.length === 0) {
      await sql`
        INSERT INTO daily_challenges (user_id, challenge_date)
        VALUES (${userId}, ${today})
      `;
    }

    // Compter le nombre d'activit√©s compl√©t√©es aujourd'hui
    const activitiesCount = await sql`
      SELECT COUNT(DISTINCT al.activity_id) as count
      FROM activity_logs al
      INNER JOIN activities a ON al.activity_id = a.id
      WHERE a.user_id = ${userId}
      AND al.date = ${today}
      AND al.is_done = true
    `;

    // Compter les activit√©s de sport compl√©t√©es aujourd'hui
    const sportCount = await sql`
      SELECT COUNT(DISTINCT al.activity_id) as count
      FROM activity_logs al
      INNER JOIN activities a ON al.activity_id = a.id
      WHERE a.user_id = ${userId}
      AND a.category = 'sport'
      AND al.date = ${today}
      AND al.is_done = true
    `;

    // Compter les activit√©s de sant√© compl√©t√©es aujourd'hui
    const healthCount = await sql`
      SELECT COUNT(DISTINCT al.activity_id) as count
      FROM activity_logs al
      INNER JOIN activities a ON al.activity_id = a.id
      WHERE a.user_id = ${userId}
      AND a.category = 'health'
      AND al.date = ${today}
      AND al.is_done = true
    `;

    // Mettre √† jour les d√©fis journaliers
    await sql`
      UPDATE daily_challenges
      SET 
        activities_completed = ${activitiesCount[0].count},
        sport_completed = ${sportCount[0].count},
        health_completed = ${healthCount[0].count},
        updated_at = CURRENT_TIMESTAMP
      WHERE user_id = ${userId}
      AND challenge_date = ${today}
    `;
  }

  revalidatePath('/dashboard');
  revalidatePath('/dashboard/challenges');
}

// Authentification
export async function authenticate(
  prevState: string | undefined,
  formData: FormData,
) {
  console.log('üîê [AUTHENTICATE] Tentative de connexion...');
  try {
    const email = formData.get('email') as string;
    const password = formData.get('password') as string;
    
    console.log('üìß Email:', email);
    
    // NE PAS passer redirectTo √† signIn - √ßa cr√©e des URLs avec localhost
    await signIn('credentials', {
      email,
      password,
      redirect: false, // IMPORTANT: D√©sactive la redirection automatique
    });
    
    console.log('‚úÖ [AUTHENTICATE] Connexion r√©ussie!');
  } catch (error) {
    console.error('‚ùå [AUTHENTICATE] Erreur:', error);
    if (error instanceof AuthError) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Identifiants invalides.';
        default:
          return 'Une erreur est survenue.';
      }
    }
    throw error;
  }
  
  // Redirection manuelle APR√àS la connexion r√©ussie
  redirect('/dashboard/home');
}

// Actions pour les d√©fis
export async function acceptChallenge(challengeId: string) {
  try {
    const session = await auth();
    if (!session?.user?.email) {
      throw new Error('Non connect√©');
    }

    // R√©cup√©rer l'ID de l'utilisateur
    const userResult = await sql`
      SELECT id FROM users WHERE email = ${session.user.email}
    `;
    
    if (userResult.length === 0) {
      throw new Error('Utilisateur non trouv√©');
    }

    const userId = userResult[0].id;

    // V√©rifier si le d√©fi existe et est actif
    const challengeResult = await sql`
      SELECT id, goal_type FROM challenges 
      WHERE id = ${challengeId} AND is_active = true
    `;

    if (challengeResult.length === 0) {
      throw new Error('D√©fi non trouv√© ou inactif');
    }

    // V√©rifier si l'utilisateur n'a pas d√©j√† accept√© ce d√©fi
    const existingResult = await sql`
      SELECT id FROM user_challenges
      WHERE user_id = ${userId} AND challenge_id = ${challengeId}
    `;

    if (existingResult.length > 0) {
      throw new Error('D√©fi d√©j√† accept√©');
    }

    // Accepter le d√©fi
    await sql`
      INSERT INTO user_challenges (user_id, challenge_id, status, progress, start_date)
      VALUES (${userId}, ${challengeId}, 'in_progress', 0, ${new Date().toISOString().split('T')[0]})
    `;

    console.log('‚úÖ D√©fi accept√© avec succ√®s');
    revalidatePath('/dashboard/challenges');
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'acceptation du d√©fi:', error);
    throw error;
  }
}

export async function completeChallenge(userChallengeId: string) {
  try {
    const session = await auth();
    if (!session?.user?.email) {
      throw new Error('Non connectÈ');
    }

    // RÈcupÈrer le user_challenge
    const userChallengeResult = await sql`
      SELECT 
        uc.*,
        c.star_reward,
        c.goal_value,
        u.id as user_id,
        u.stars
      FROM user_challenges uc
      INNER JOIN challenges c ON uc.challenge_id = c.id
      INNER JOIN users u ON uc.user_id = u.id
      WHERE uc.id = ${userChallengeId} AND u.email = ${session.user.email}
    `;

    if (userChallengeResult.length === 0) {
      throw new Error('DÈfi non trouvÈ');
    }

    const userChallenge = userChallengeResult[0];

    // VÈrifier que le dÈfi est complÈtÈ
    if (userChallenge.progress < userChallenge.goal_value) {
      throw new Error('DÈfi pas encore complÈtÈ');
    }

    // Marquer le dÈfi comme complÈtÈ
    await sql`
      UPDATE user_challenges
      SET status = 'completed', completed_at = ${new Date().toISOString()}
      WHERE id = ${userChallengeId}
    `;

    // Ajouter XP et stars avec le systËme de level
    const { addUserXp } = await import('./level-actions');
    await addUserXp(session.user.email, userChallenge.star_reward);

    console.log(` DÈfi complÈtÈ! +${userChallenge.star_reward} Ètoiles/XP`);
    revalidatePath('/dashboard/challenges');
    revalidatePath('/dashboard/badges');
    revalidatePath('/dashboard/profile');
  } catch (error) {
    console.error(' Erreur lors de la complÈtion du dÈfi:', error);
    throw error;
  }
}
